<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Flink详细介绍 | ZBlog</title>
  
  
  <meta name="description" content="技术和生活，融为一体">
  

  
  <link rel="alternate" href="/atom.xml" title="ZBlog">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>ZBlog</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;项目
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          ZBlog
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;所有博客
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/09/02/Flink详细介绍/">
        Flink详细介绍
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>赵鑫涛</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-09-02</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/基础/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>基础</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567329814966.png" alt="1567329814966"></p>
<h2 id="Flink详细介绍"><a href="#Flink详细介绍" class="headerlink" title="Flink详细介绍"></a>Flink详细介绍</h2><h3 id="Flink-API的抽象级别"><a href="#Flink-API的抽象级别" class="headerlink" title="Flink API的抽象级别"></a>Flink API的抽象级别</h3><a id="more"></a>

<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567329798038.png" alt="1567329798038"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567329931681.png" alt="1567329931681"></li>
</ul>
<h3 id="Flink-DataStreamAPI"><a href="#Flink-DataStreamAPI" class="headerlink" title="Flink DataStreamAPI"></a>Flink DataStreamAPI</h3><h4 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h4><ul>
<li><p>source是程序的数据源输入，可以通过StreamExecutionEnvironment.addSource(sourceFunction来给程序添加一个source</p>
</li>
<li><p>Flink提供了大量已经实现好的source方法，我们也可以自定义source</p>
<ul>
<li>通过实现sourceFunction接口来自定义无并行度的source</li>
<li>或者你也可以通过实现ParallelSourceFunction 接口<br>or 继承RichParallelSourceFunction 来自定义有并行度的source。</li>
</ul>
</li>
<li><p>source的类型</p>
<ul>
<li>基于socket<ul>
<li>socketTextStream<br>从socket中读取数据，元素可以通过一个分隔符切开。</li>
</ul>
</li>
<li>基于集合<ul>
<li>fromCollection(Collection)</li>
<li>通过java的collection集合创建一个数据流，集合中的所有元素必须是相同类型的。</li>
</ul>
</li>
<li>自定义输入<ul>
<li>addSource 可以实现读取第三方数据源的数据</li>
<li>系统内置提供了一批connectors，连接器会提供对应的source支持</li>
</ul>
</li>
</ul>
</li>
<li><p>内置connectors 连接器</p>
<ul>
<li>Apache Kafka (source/sink)</li>
<li>RabbitMQ (source/sink)</li>
<li>Apache ActiveMQ (source/sink)</li>
</ul>
</li>
<li><p>source的容错性保证</p>
<ul>
<li><table>
<thead>
<tr>
<th><strong>Source</strong></th>
<th><strong>语义保证</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>kafka</td>
<td>exactly once(仅一次)</td>
<td>建议使用0.10及以上</td>
</tr>
<tr>
<td>Collections</td>
<td>exactly once</td>
<td></td>
</tr>
<tr>
<td>Files</td>
<td>exactly once</td>
<td></td>
</tr>
<tr>
<td>Sockets</td>
<td>at most once</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><ul>
<li>map：输入一个元素，然后返回一个元素，中间可以做一些清洗转换等操作</li>
<li>flatmap：输入一个元素，可以返回零个，一个或者多个元素</li>
<li>filter：过滤函数，对传入的数据进行判断，符合条件的数据会被留下</li>
<li>keyby：根据指定的key进行分组，相同key的数据会进入同一个分区</li>
<li>reduce：对数据进行聚合操作，结合当前元素和上一次reduce返回的值进行聚合操作，然后返回一个新的值</li>
<li>aggregations：sum(),min(),max()等</li>
<li>window：后面会详细描述</li>
<li>union：合并多个流，新的流会包含所有流中的数据  注意：所有合并的流类型必须是一致的</li>
<li>connect：和union类似，但是只能连接两个流，两个流的数据类型可以不同，会对两个流中的数据应用不同的处理方法。<ul>
<li>CoMap,  CoFlatMap：在ConnectedStreams中需要使用这种函数，类似于map和flatmap</li>
</ul>
</li>
</ul>
<h4 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h4><ul>
<li><p>输出的类型</p>
<ul>
<li>writeAsText（）：将元素以字符串形式逐行写入，这些字符串通过调用每个元素的toString()方法来获取</li>
<li>print（）/printToErr（）：打印每个元素的toString()方法的值到标准输出或者标准错误输出流中</li>
<li>自定义输出addSink  例如：kafka Redis等</li>
</ul>
</li>
<li><p>内置connectors连接器</p>
<ul>
<li>Apache Kafka (source/sink)</li>
<li>Apache Cassandra (sink)</li>
<li>Elasticsearch (sink)</li>
<li>Hadoop FileSystem (sink)</li>
<li>RabbitMQ (source/sink)</li>
<li>Apache ActiveMQ (source/sink)</li>
<li>Redis (sink)</li>
</ul>
</li>
<li><p>sink的容错性保证</p>
<ul>
<li><table>
<thead>
<tr>
<th><strong>Sink</strong></th>
<th><strong>语义保证</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdfs</td>
<td>exactly once</td>
<td></td>
</tr>
<tr>
<td>elasticsearch</td>
<td>at least once</td>
<td></td>
</tr>
<tr>
<td>kafka produce</td>
<td>at least once/exactly once</td>
<td>Kafka 0.9 and 0.10提供at   least once   Kafka 0.11提供exactly once</td>
</tr>
<tr>
<td>file</td>
<td>at least once</td>
<td></td>
</tr>
<tr>
<td>redis</td>
<td>at least once</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>自定义sink</p>
<ul>
<li>实现自定义sink<ul>
<li>实现SinkFunction接口</li>
<li>继承RichSinkFunction</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Flink-DataSetAPI"><a href="#Flink-DataSetAPI" class="headerlink" title="Flink DataSetAPI"></a>Flink DataSetAPI</h3><h4 id="DataSource-1"><a href="#DataSource-1" class="headerlink" title="DataSource"></a>DataSource</h4><ul>
<li>基于文件<ul>
<li>readTextFile(path)</li>
</ul>
</li>
<li>基于集合<ul>
<li>fromCollection(Collection)</li>
</ul>
</li>
</ul>
<h4 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h4><ul>
<li>map：输入一个元素，然后返回一个元素，中间可以做一些清洗转换等操作</li>
<li>flatmap：输入一个元素，可以返回零个，一个或者多个元素</li>
<li>mappartition：类似map，一次处理一个分区的数据【如果在进行map处理的时候需要获取第三方资源链接，建议使用MapPartition】</li>
<li>filter：过滤函数，对传入的数据进行判断，符合条件的数据会被留下</li>
<li>reduce：对数据进行聚合操作，结合当前元素和上一次reduce返回的值进行聚合操作，然后返回一个新的值</li>
<li>Aggregate：sum、max、min等</li>
<li>distinct：返回一个数据集中去重之后的元素，data.distinct()</li>
<li>cross：获取两个数据集的笛卡尔积</li>
<li>union：返回两个数据集的总和，数据类型需要一致</li>
<li>first-n: 获取集合中的前N个元素</li>
<li>Sort Partition：在本地对数据集的所有分区进行排序，通过sortPartition()的链接调用来完成对多个字段的排序</li>
</ul>
<h4 id="sink-1"><a href="#sink-1" class="headerlink" title="sink"></a>sink</h4><ul>
<li>writeAsText():将元素以字符串形式逐行写入，这些字符串通过调用每个元素的toString()方法来获取</li>
<li>writeAsCsv():将元组以逗号分隔写入文件中，行及字段之间的分隔是可配置的。每个字段的值来自对象的toString()方法</li>
<li>print():打印每个元素的toString()方法的值到标准输出或者标准错误输出流中</li>
</ul>
<h3 id="Flink-SQL"><a href="#Flink-SQL" class="headerlink" title="Flink SQL"></a>Flink SQL</h3><ul>
<li>Flink针对流处理和批处理提供了相关的API-Table API和SQL。</li>
<li>注意：目前Table API和SQL功能尚未全部完成，官方正在积极开发中。</li>
<li>暂时不推荐使用 故暂时不解释其用法</li>
</ul>
<h3 id="Flink-Broadcast-amp-Accumulators-amp-Counters"><a href="#Flink-Broadcast-amp-Accumulators-amp-Counters" class="headerlink" title="Flink Broadcast &amp; Accumulators &amp; Counters"></a>Flink Broadcast &amp; Accumulators &amp; Counters</h3><h4 id="Broadcast广播变量"><a href="#Broadcast广播变量" class="headerlink" title="Broadcast广播变量"></a>Broadcast广播变量</h4><ul>
<li>广播变量允许编程人员在每台机器上保持1个只读的缓存变量，而不是传送变量的副本给tasks</li>
<li>广播变量创建后，它可以运行在集群中的任何function上，而不需要多次传递给集群节点。另外需要记住，不应该修改广播变量，这样才能确保每个节点获取到的值都是一致的</li>
<li>一句话解释，可以理解为是一个公共的共享变量，我们可以把一个dataset数据集广播出去，然后不同的task在节点上都能够获取到，这个数据在每个节点上只会存在一份。如果不使用broadcast，则在每个节点中的每个task中都需要拷贝一份dataset数据集，比较浪费内存(也就是一个节点中可能会存在多份dataset数据)。</li>
<li>用法：<ul>
<li>初始化数据<ul>
<li>DataSet<integer> toBroadcast = env.fromElements(1, 2, 3);</integer></li>
</ul>
</li>
<li>广播数据<ul>
<li>.withBroadcastSet(toBroadcast,”broadcastSetName”);</li>
</ul>
</li>
<li>获取广播数据<ul>
<li>Collection<integer> broadcastSet =<br>getRuntimeContext().getBroadcastVariable(“broadcastSetName”);</integer></li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>广播出去的变量存在于每个节点的内存中，所以这个数据集不能太大。因为广播出去的数据，会常驻内存，除非程序执行结束</li>
<li>广播变量在初始化广播出去以后不支持修改，这样才能保证每个节点的数据都是一致的。</li>
</ul>
</li>
</ul>
<h4 id="Accumulators-累加器"><a href="#Accumulators-累加器" class="headerlink" title="Accumulators 累加器"></a>Accumulators 累加器</h4><ul>
<li>Accumulator即累加器，与Mapreduce counter的应用场景差不多，都能很好地观察task在运行期间的数据变化</li>
<li>可以在Flink job任务中的算子函数中操作累加器，但是只能在任务执行结束之后才能获得累加器的最终结果。</li>
</ul>
<h4 id="Counters-计数器"><a href="#Counters-计数器" class="headerlink" title="Counters 计数器"></a>Counters 计数器</h4><ul>
<li>Counter是一个具体的累加器(Accumulator)实现<ul>
<li>IntCounter, LongCounter 和 DoubleCounter</li>
</ul>
</li>
<li>用法：<ul>
<li>创建累加器<ul>
<li>private IntCounter numLines = new IntCounter();</li>
</ul>
</li>
<li>注册累加器<ul>
<li>getRuntimeContext().addAccumulator(“num-lines”,this.numLines);</li>
</ul>
</li>
<li>使用累加器<ul>
<li>this.numLines.add(1); </li>
</ul>
</li>
<li>获取累加器的结果<ul>
<li>myJobExecutionResult.getAccumulatorResult(“num-lines”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="广播变量-Broadcast-与-累加变量-Accumlators的区别"><a href="#广播变量-Broadcast-与-累加变量-Accumlators的区别" class="headerlink" title="广播变量 Broadcast 与 累加变量 Accumlators的区别"></a>广播变量 Broadcast 与 累加变量 Accumlators的区别</h4><ul>
<li>Broadcast(广播变量)允许程序员将一个只读的变量缓存在每台机器上，而不用在任务之间传递变量。广播变量可以进行共享，但是不可以进行修改</li>
<li>Accumulators(累加器)是可以在不同任务中对同一个变量进行累加操作。</li>
</ul>
<h3 id="Flink-Window和Time详解"><a href="#Flink-Window和Time详解" class="headerlink" title="Flink Window和Time详解"></a>Flink Window和Time详解</h3><h4 id="Window窗口"><a href="#Window窗口" class="headerlink" title="Window窗口"></a>Window窗口</h4><ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567337912453.png" alt="1567337912453"></li>
<li>聚合事件例如计数、求和，在流上的工作方式与批处理不同<ul>
<li>比如，对流中的所有元素进行计数是不可能的，因为通常流是无限的（无界的）。所以，流上的聚合需要由window 来划定范围，比如 “计算过去的5分钟” ，或者“最后100个元素的和” </li>
<li>window是一种可以把无限数据切割为有限数据块的手段</li>
</ul>
</li>
<li>窗口可以是 时间驱动的 【Time Window】（比如：每30秒）或者数据驱动的【Count  Window】（比如：每100个元素）</li>
<li>widow窗口的类型<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338078663.png" alt="1567338078663"></li>
<li>tumbling windows：滚动窗口 【没有重叠】<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338109467.png" alt="1567338109467"></li>
</ul>
</li>
<li>sliding windows：滑动窗口 【有重叠】 <ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338132782.png" alt="1567338132782"></li>
</ul>
</li>
</ul>
</li>
<li>widow窗口的应用<ul>
<li>TimeWindow的应用<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338320496.png" alt="1567338320496"></li>
</ul>
</li>
<li>Count window<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338375799.png" alt="1567338375799"></li>
</ul>
</li>
<li>自定义window<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338475470.png" alt="1567338475470"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338483107.png" alt="1567338483107"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338514024.png" alt="1567338514024"></li>
</ul>
</li>
</ul>
</li>
<li>window聚合分类<ul>
<li>增量聚合<ul>
<li>在窗口中每进一条数据就进行一次聚合计算</li>
<li>reduce(reduceFunction)</li>
<li>aggregate(aggregateFunction)</li>
<li>sum(),min(),max()</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338666708.png" alt="1567338666708"></li>
<li>实现过程<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338695987.png" alt="1567338695987"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338704045.png" alt="1567338704045"></li>
</ul>
</li>
</ul>
</li>
<li>全量聚合<ul>
<li>等窗口中的所有数据到齐以后才进行聚合计算，可以实现对窗口内所有数据的排序等需求</li>
<li>apply(windowFunction)</li>
<li>process(processWindowFunction)   提供了更多上下文的信息</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338848386.png" alt="1567338848386"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338884621.png" alt="1567338884621"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338900562.png" alt="1567338900562"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567338909177.png" alt="1567338909177"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Time介绍"><a href="#Time介绍" class="headerlink" title="Time介绍"></a>Time介绍</h4><ul>
<li><p>针对stream中的时间，可以分为以下三种</p>
<ul>
<li>Event Time：事件产生的时间，通常由事件中的时间戳来描述</li>
<li>Ingestion Time:  事件进入Flink的时间</li>
<li>Processing time ： 时间倍处理时当前系统时间</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567339213593.png" alt="1567339213593"></li>
</ul>
</li>
<li><p>Time实例分析</p>
<ul>
<li><p>原始日志</p>
<ul>
<li>2018-10-10 10:00:01,134 INFO executor.Executor: Finished task in state 0.0</li>
</ul>
</li>
<li><p>数据进入Flink的时间是：2018-10-10 20:00:00,102</p>
</li>
<li><p>数据到达window进行处理的时间是：2018-10-10 20:00:01,100 </p>
</li>
<li><p>如果我们想要统计每分钟内接口调用失败的错误日志个数，使用哪个时间才有意义？</p>
<ul>
<li>Flink中，默认Time是ProcessingTime</li>
<li>可以在代码中设置<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567339399845.png" alt="1567339399845"></li>
</ul>
</li>
<li>但是Processing time 并不是我们特别想要的，因为日志文件在传输过程中顺序可能已经发生了变化，而我们想要的是错误日志产生时的信息，就是Event Time，所以我们需要考虑一下Event Time的乱序问题</li>
</ul>
</li>
<li><p>EventTime和Watermarks</p>
</li>
<li><p>在使用eventTime的时候如何处理乱序数据？</p>
<ul>
<li>我们知道，流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络延迟等原因，导致乱序的产生，特别是使用kafka的话，多个分区的数据无法保证有序。所以在进行window计算的时候，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark，watermark是用于处理乱序事件的。</li>
<li>watermark可以翻译为水位线</li>
</ul>
</li>
<li><p>有序流与无序流图解</p>
<ul>
<li>有序流</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567340864838.png" alt="1567340864838"></li>
<li>指定在那个时间点断开进行计算就可以直接断开进行计算</li>
<li>无序流</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567340912113.png" alt="1567340912113"></li>
<li>因为顺序被打乱 指定在某时间断开 其中的数据是错乱的无法进行立即聚合处理</li>
</ul>
</li>
<li><p>watermarks的使用</p>
</li>
<li><p>watermarks的生成方式有两种</p>
<ul>
<li>With Periodic Watermarks：周期性的触发watermark 的生成和发送</li>
<li>With Punctuated Watermarks：基于某些事件触发watermark 的生成和发送</li>
<li>第一种是我们常用的方法，所以就第一种来进行详细的分析</li>
</ul>
</li>
<li><p>参考官方文档中With Periodic Watermarks的使用方法</p>
<ul>
<li><p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567341414170.png" alt="1567341414170"></p>
</li>
<li><p>代码中的extractTimestamp方法是从数据本身提取数据的Event time，getCurrentWatermar方法是获取当前水位线，利用currentMaxTimestamp - maxOutOfOrderness ，maxOutOfOrderness表示的是允许数据最大乱序时间</p>
<p>所以在这里我们需要使用的话就需要实现接口AssignerWithPeriodicWatermarks</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567341604475.png" alt="1567341604475"></p>
</li>
</ul>
</li>
<li><p>实现watermark的相关代码</p>
</li>
<li><p>从socket模拟接收数据，然后使用map进行处理，后面在调用assignTimestampsAndWatermarks方法抽取timestamp并生成watermark。在调用window 打印信息来验证window被触发的时机</p>
</li>
<li><p>具体代码如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.WindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.Watermark;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watermark 案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingWindowWatermark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义 socket 的端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9001</span>;</span><br><span class="line">        <span class="comment">// 获取运行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置使用 eventtime，默认是使用 processtime</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line">        <span class="comment">//设置并行度为 1,默认并行度是当前机器的 cpu 数量</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//连接 socket 获取输入的数据</span></span><br><span class="line">        DataStream&lt;String&gt; text = env.socketTextStream(<span class="string">"hadoop100"</span>, port, <span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">//解析输入的数据</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Long&gt;&gt; inputMap = text.map(<span class="keyword">new</span> MapFunction&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] arr = value.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(arr[<span class="number">0</span>], Long.parseLong(arr[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//抽取 timestamp 和生成 watermark</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Long&gt;&gt; waterMarkStream = inputMap.assignTimestampsAndWatermarks(<span class="keyword">new</span> AssignerWithPeriodicWatermarks&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">            Long currentMaxTimestamp = <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">// 最大允许的乱序时间是 10s</span></span><br><span class="line">            <span class="keyword">final</span> Long maxOutOfOrderness = <span class="number">10000L</span>;</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 定义生成 watermark 的逻辑 * 默认 100ms 被调用一次</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Watermark <span class="title">getCurrentWatermark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Watermark(currentMaxTimestamp - maxOutOfOrderness);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义如何提取 timestamp</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; element, <span class="keyword">long</span> previousElementTimestamp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> timestamp = element.f1;</span><br><span class="line">                currentMaxTimestamp = Math.max(timestamp, currentMaxTimestamp);</span><br><span class="line">                System.out.println(<span class="string">"key:"</span> + element.f0 + <span class="string">",eventtime:["</span> + element.f1 + <span class="string">"|"</span> + sdf.format(element.f1) + <span class="string">"], currentMaxTimestamp:["</span> + currentMaxTimestamp + <span class="string">"|"</span> + sdf.format(currentMaxTimestamp) + <span class="string">"],watermark:["</span> + getCurrentWatermark().getTimestamp() + <span class="string">"|"</span> + sdf.format(getCurrentWatermark().getTimestamp()) + <span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//分组，聚合</span></span><br><span class="line">        DataStream&lt;String&gt; window = waterMarkStream.keyBy(<span class="number">0</span>)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">3</span>)))<span class="comment">// 按 照 消 息 的 EventTime 分配窗口，和调用 TimeWindow 效果一样</span></span><br><span class="line">                .apply(<span class="keyword">new</span> WindowFunction&lt;Tuple2&lt;String, Long&gt;, String, Tuple, TimeWindow&gt;() &#123;</span><br><span class="line">                    <span class="comment">/*** 对 window 内的数据进行排序，保证数据的顺序</span></span><br><span class="line"><span class="comment">                     * * <span class="doctag">@param</span> tuple * <span class="doctag">@param</span> window * <span class="doctag">@param</span> input * <span class="doctag">@param</span> out * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">                     * */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Tuple tuple, TimeWindow window, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        String key = tuple.toString();</span><br><span class="line">                        List&lt;Long&gt; arrarList = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">                        Iterator&lt;Tuple2&lt;String, Long&gt;&gt; it = input.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            Tuple2&lt;String, Long&gt; next = it.next();</span><br><span class="line">                            arrarList.add(next.f1);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Collections.sort(arrarList);</span><br><span class="line">                        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">                        String result = key + <span class="string">","</span> + arrarList.size() + <span class="string">","</span> + sdf.format(arrarList.get(<span class="number">0</span>)) + <span class="string">","</span> + sdf.format(arrarList.get(arrarList.size() - <span class="number">1</span>)) + <span class="string">","</span> + sdf.format(window.getStart()) + <span class="string">","</span> + sdf.format(window.getEnd());</span><br><span class="line">                        out.collect(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//测试-把结果打印到控制台即可</span></span><br><span class="line">        window.print();</span><br><span class="line">        <span class="comment">//注意：因为 flink 是懒加载的，所以必须调用 execute 方法，上面的代码才会执行</span></span><br><span class="line">        env.execute(<span class="string">"eventtime-watermark"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序简单解释</p>
<ul>
<li>接收socket传来的数据</li>
<li>将每行数据按照逗号分隔，每行数据调用map 转换成tuple&lt;String,Long&gt;类型。其中tuple 中的第一个元素代表具体的数据，第二个元素代表数据的eventtime</li>
<li>抽取timestamp ， 生成watermar ， 允许的最大乱序时间是10s ， 并打印<br>（key,eventtime,currentMaxTimestamp,watermark）等信息</li>
<li>分组聚合，window 窗口大小为3 秒，输出（key，窗口内元素个数，窗口内最早元素的<br>时间，窗口内最晚元素的时间，窗口自身开始时间，窗口自身结束时间）</li>
</ul>
</li>
<li><p>测试数据</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">测试数据-1如下：watermark+window处理乱序数据</span><br><span class="line">0001,1538359882000		2018-10-01 10:11:22</span><br><span class="line">0001,1538359886000		2018-10-01 10:11:26</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line">0001,1538359893000		2018-10-01 10:11:33</span><br><span class="line">0001,1538359894000		2018-10-01 10:11:34</span><br><span class="line">0001,1538359896000		2018-10-01 10:11:36</span><br><span class="line">0001,1538359897000		2018-10-01 10:11:37</span><br><span class="line"></span><br><span class="line">0001,1538359899000		2018-10-01 10:11:39</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359903000		2018-10-01 10:11:43</span><br><span class="line"></span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试数据-2如下：延迟数据被丢弃</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359903000		2018-10-01 10:11:43</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试数据-3如下：allowedLateness </span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359903000		2018-10-01 10:11:43</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line">0001,1538359904000		2018-10-01 10:11:44</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line">0001,1538359905000		2018-10-01 10:11:45</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试数据-4如下：sideOutputLateData </span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359903000		2018-10-01 10:11:43</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359891000		2018-10-01 10:11:31</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试数据-5如下：多并行度下的watermark-8</span><br><span class="line">0001,1538359882000		2018-10-01 10:11:22</span><br><span class="line">0001,1538359886000		2018-10-01 10:11:26</span><br><span class="line">0001,1538359892000		2018-10-01 10:11:32</span><br><span class="line">0001,1538359893000		2018-10-01 10:11:33</span><br><span class="line">0001,1538359894000		2018-10-01 10:11:34</span><br><span class="line">0001,1538359896000		2018-10-01 10:11:36</span><br><span class="line">0001,1538359897000		2018-10-01 10:11:37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试数据-6如下：</span><br><span class="line">0001,1538359890000		2018-10-01 10:11:30</span><br><span class="line">0001,1538359903000		2018-10-01 10:11:43</span><br><span class="line">0001,1538359908000		2018-10-01 10:11:48</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567345375589.png" alt="1567345375589"></p>
</li>
<li><p>注意：多并行度的情况下，watermark对齐会取所有channel最小的watermark</p>
</li>
<li><p>watermarks的生成方式</p>
<ul>
<li><p>With Periodic Watermarks</p>
<p>周期性的触发watermark的生成和发送，默认是100ms</p>
<p>每隔N秒自动向流里注入一个WATERMARK 时间间隔由ExecutionConfig.setAutoWatermarkInterval 决定. 每次调用getCurrentWatermark 方法, 如果得到的WATERMARK 不为空并且比之前的大就注入流中 </p>
<p>可以定义一个最大允许乱序的时间，这种比较常用</p>
<p>实现AssignerWithPeriodicWatermarks接口</p>
</li>
<li><p>With Punctuated Watermarks</p>
<p>基于某些事件触发watermark的生成和发送</p>
<p>基于事件向流里注入一个WATERMARK，每一个元素都有机会判断是否生成一个WATERMARK. 如果得到的WATERMARK 不为空并且比之前的大就注入流中</p>
<p>实现AssignerWithPunctuatedWatermarks接口</p>
</li>
</ul>
</li>
<li><p>watermark  与 event time结合使用</p>
<ul>
<li>触发widow进行合并的条件是  watermark &gt;= window_end_time  并且当前窗口内有数据</li>
<li>这样就可以在允许最大乱序时间内将同一个窗口的数据进行处理，如果数据超过了这个最大允许乱序时间，要怎么解决呢</li>
</ul>
</li>
<li><p>late element 延迟数据的处理方案</p>
<ul>
<li>丢弃 系统默认的方法<ul>
<li>直接将超过允许最大乱序时间的数据丢弃，不做任何处理</li>
</ul>
</li>
<li>allowedLateness  指定允许数据延迟时间<ul>
<li>再给迟到的数据一个提供一个宽容时间</li>
<li>加上这个时间以后 在超过最大允许乱序时间以后 在宽容时间内 如果数据出现了 依然可以出发widow执行。</li>
</ul>
</li>
<li>sideOutputLateDate  收集迟到的数据<ul>
<li>通过sideOutputLateDate将迟到的数据进行统一收集进行存储，方便 以后的问题排查处理</li>
</ul>
</li>
</ul>
</li>
<li><p>Flink应该如何设置最大乱序时间</p>
<ul>
<li>这个要结合自己的业务以及数据情况去设置。如果maxOutOfOrderness设置的太小，而自身数据发送时由于网络等原因导致乱序或者late太多，那么最终的结果就是会有很多单条的数据在window中被触发，数据的正确性影响太大</li>
<li>对于严重乱序的数据，需要严格统计数据最大延迟时间，才能保证计算的数据准确，延时设置太小会影响数据准确性，延时设置太大不仅影响数据的实时性，更加会加重Flink作业的负担，不是对eventTime要求特别严格的数据，尽量不要采用eventTime方式来处理，会有丢数据的风险。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Flink-并行度详解-Parallel"><a href="#Flink-并行度详解-Parallel" class="headerlink" title="Flink 并行度详解(Parallel )"></a>Flink 并行度详解(Parallel )</h3><h4 id="TaskManager-与-Slot"><a href="#TaskManager-与-Slot" class="headerlink" title="TaskManager 与 Slot"></a>TaskManager 与 Slot</h4><ul>
<li>Flink的每个TaskManager为集群提供solt。 solt的数量通常与每个TaskManager节点的可用CPU内核数成比例。一般情况下你的slot数是你每个节点的cpu的核数。<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433392285.png" alt="1567433392285"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433422808.png" alt="1567433422808"></li>
</ul>
</li>
</ul>
<h4 id="并行度（Parallel）"><a href="#并行度（Parallel）" class="headerlink" title="并行度（Parallel）"></a>并行度（Parallel）</h4><ul>
<li>一个Flink程序由多个任务组成(source、transformation和 sink)。 一个任务由多个并行的实例(线程)来执行， 一个任务的并行实例(线程)数目就被称为该任务的并行度。</li>
<li>一个任务的并行度设置可以从多个层次指定<ul>
<li>Operator Level（算子层次）</li>
<li>Execution Environment Level（执行环境层次）</li>
<li>Client Level（客户端层次）</li>
<li>System Level（系统层次）</li>
</ul>
</li>
<li>并行度设置之Operator Level<ul>
<li>一个算子、数据源和sink的并行度可以通过调用 setParallelism()方法来指定</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433659150.png" alt="1567433659150"></li>
</ul>
</li>
<li>并行度设置之Execution Environment Level<ul>
<li>执行环境(任务)的默认并行度可以通过调用setParallelism()方法指定。为了以并行度3来执行所有的算子、数据源和data sink， 可以通过如下的方式设置执行环境的并行度</li>
<li>执行环境的并行度可以被算子的并行度覆盖重写</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433733701.png" alt="1567433733701"></li>
</ul>
</li>
<li>并行度设置之Client Level<ul>
<li>并行度可以在客户端将job提交到Flink时设定。</li>
<li>对于CLI客户端，可以通过-p参数指定并行度</li>
<li>./bin/flink run <strong>-p</strong> 10 WordCount-java.jar</li>
</ul>
</li>
<li>并行度设置之System Level<ul>
<li>在系统级可以通过设置flink-conf.yaml文件中的parallelism.default属性来指定所有执行环境的默认并行度</li>
</ul>
</li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433861193.png" alt="1567433861193"></li>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567433868135.png" alt="1567433868135"></li>
</ul>
<h3 id="Flink的checkpoint机制"><a href="#Flink的checkpoint机制" class="headerlink" title="Flink的checkpoint机制"></a>Flink的checkpoint机制</h3><h4 id="checkpoint简介"><a href="#checkpoint简介" class="headerlink" title="checkpoint简介"></a>checkpoint简介</h4><ul>
<li>为了保证state的容错性，Flink需要对state进行checkpoint</li>
<li>Checkpoint是Flink实现容错机制最核心的功能，它能够根据配置周期性地基于Stream中各个Operator/task的状态来生成快照，从而将这些状态数据定期持久化存储下来，当Flink程序一旦意外崩溃时，重新运行程序时可以有选择地从这些快照进行恢复，从而修正因为故障带来的程序数据异常</li>
<li>Flink的checkpoint机制可以与(stream和state)的持久化存储交互的前提：<ul>
<li>持久化的source，它需要支持在一定时间内重放事件。这种sources的典型例子是持久化的消息队列（比如Apache  Kafka，RabbitMQ等）或文件系统（比如HDFS，S3，GFS等）</li>
<li>用于state的持久化存储，例如分布式文件系统（比如HDFS，S3，GFS等）</li>
</ul>
</li>
</ul>
<h4 id="checkpoint的配置"><a href="#checkpoint的配置" class="headerlink" title="checkpoint的配置"></a>checkpoint的配置</h4><ul>
<li><p>默认的情况下 checkpoint是disabled不可用状态，想要使用的时候先开启</p>
</li>
<li><p>checkpoint的checkPointMode有两种，Exactly-once(默认)和At-least-once</p>
</li>
<li><p>Exactly-once对于大多数应用来说是最合适的。At-least-once可能用在某些延迟超低的应用程序（始终延迟为几毫秒）</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 每隔1000 ms进行启动一个检查点【设置checkpoint的周期】</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 高级选项：</span></span><br><span class="line"><span class="comment">// 设置模式为exactly-once （这是默认值）</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 确保检查点之间有至少500 ms的间隔【checkpoint最小间隔】</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// 检查点必须在一分钟内完成，或者被丢弃【checkpoint的超时时间】</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 同一时间只允许进行一个检查点</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 表示一旦Flink处理程序被cancel后，会保留Checkpoint数据，以便根据实际需要恢复到指定的Checkpoint</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="state-Backend-状态的后端存储"><a href="#state-Backend-状态的后端存储" class="headerlink" title="state Backend 状态的后端存储"></a>state Backend 状态的后端存储</h4><ul>
<li><p>默认情况下，state会保存在taskmanager的内存中，checkpoint会存储在JobManager的内存中。</p>
</li>
<li><p>state 和checkpoint的存储位置取决于State Backend的配置  可以在程序中修改</p>
<ul>
<li>env.setStateBackend(…)</li>
</ul>
</li>
<li><p>三种state Backend</p>
</li>
<li><p>MemoryStateBackend</p>
<ul>
<li>state数据保存在java堆内存中，执行checkpoint的时候，会把state的快照数据保存到jobmanager的内存中</li>
<li>基于内存的state backend在生产环境下不建议使用</li>
</ul>
</li>
<li><p>FsStateBackend</p>
<ul>
<li>state数据保存在taskmanager的内存中，执行checkpoint的时候，会把state的快照数据保存到配置的文件系统中</li>
<li>可以使用hdfs等分布式文件系统</li>
</ul>
</li>
<li><p><strong>RocksDBStateBackend</strong></p>
<ul>
<li>RocksDB跟上面的都略有不同，它会在本地文件系统中维护状态，state会直接写入本地rocksdb中。同时它需要配置一个远端的filesystem uri（一般是HDFS），在做checkpoint的时候，会把本地的数据直接复制到filesystem中。fail over的时候从filesystem中恢复到本地</li>
<li>RocksDB克服了state受内存限制的缺点，同时又能够持久化到远端文件系统中，比较适合在生产中使用</li>
</ul>
</li>
<li><p>修改state Backend </p>
<ul>
<li><p><strong>单任务调整</strong></p>
</li>
<li><p>修改当前任务代码</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env.setStateBackend(new FsStateBackend(&quot;hdfs://namenode:9000/flink/checkpoints&quot;));</span><br><span class="line">or new MemoryStateBackend()</span><br><span class="line">or new RocksDBStateBackend(filebackend, true);【需要添加第三方依赖】</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局调整</p>
</li>
<li><p>修改flink-conf.yaml</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state.backend: filesystem</span><br><span class="line">state.checkpoints.dir: hdfs:<span class="comment">//namenode:9000/flink/checkpoints</span></span><br><span class="line">注意：state.backend的值可以是下面几种：jobmanager(MemoryStateBackend), filesystem(FsStateBackend), rocksdb(RocksDBStateBackend)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Flink-Kafka-Connector详解"><a href="#Flink-Kafka-Connector详解" class="headerlink" title="Flink Kafka-Connector详解"></a>Flink Kafka-Connector详解</h3><h4 id="kafka-connector简介"><a href="#kafka-connector简介" class="headerlink" title="kafka-connector简介"></a>kafka-connector简介</h4><ul>
<li>Kafka中的partition机制和Flink的并行度机制深度结合</li>
<li>Kafka可以作为Flink的source和sink</li>
<li>任务失败，通过设置kafka的offset来恢复应用</li>
</ul>
<h4 id="kafka-consumer消费者策略"><a href="#kafka-consumer消费者策略" class="headerlink" title="kafka-consumer消费者策略"></a>kafka-consumer消费者策略</h4><ul>
<li><strong>setStartFromGroupOffsets()</strong>【默认消费策略】<ul>
<li>默认读取上次保存的offset信息</li>
<li>如果是应用第一次启动，读取不到上次的offset信息，则会根据这个参数auto.offset.reset的值来进行消费数据</li>
</ul>
</li>
<li>setStartFromEarliest()<ul>
<li>从最早的数据开始进行消费，忽略存储的offset信息</li>
</ul>
</li>
<li><strong>setStartFromLatest()</strong><ul>
<li>从最新的数据进行消费，忽略存储的offset信息</li>
</ul>
</li>
<li>setStartFromSpecificOffsets(Map&lt;KafkaTopicPartition,Long&gt;)<ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567435618888.png" alt="1567435618888"></li>
</ul>
</li>
</ul>
<h4 id="kafka的容错"><a href="#kafka的容错" class="headerlink" title="kafka的容错"></a>kafka的容错</h4><ul>
<li>当checkpoint机制开启的时候，Kafka Consumer会定期把kafka的offset信息还有其他operator的状态信息一块保存起来。当job失败重启的时候，Flink会从最近一次的checkpoint中进行恢复数据，重新消费kafka中的数据。</li>
<li>为了能够使用支持容错的kafka Consumer，需要开启checkpoint<ul>
<li>env.enableCheckpointing(5000); // 每5s checkpoint一次</li>
</ul>
</li>
</ul>
<h4 id="动态加载topic"><a href="#动态加载topic" class="headerlink" title="动态加载topic"></a>动态加载topic</h4><ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567435791533.png" alt="1567435791533"></li>
</ul>
<h4 id="kafka-consumer-offset-自动提交"><a href="#kafka-consumer-offset-自动提交" class="headerlink" title="kafka consumer offset 自动提交"></a>kafka consumer offset 自动提交</h4><ul>
<li>针对job是否开启checkpoint来区分<ul>
<li>Checkpoint关闭时： 可以通过下面两个参数配置<ul>
<li>enable.auto.commit</li>
<li>auto.commit.interval.ms</li>
</ul>
</li>
<li>Checkpoint开启时：当执行checkpoint的时候才会保存offset，这样保证了kafka的offset和checkpoint的状态偏移量保持一致。<ul>
<li>可以通过这个参数设置setCommitOffsetsOnCheckpoints(boolean)这个参数默认就是true。表示在checkpoint的时候提交offset 此时，kafka中的自动提交机制就会被忽略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h4><ul>
<li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1567436059578.png" alt="1567436059578"></li>
</ul>
<h4 id="kafka-producer-的容错-kafka0-9-与-0-10"><a href="#kafka-producer-的容错-kafka0-9-与-0-10" class="headerlink" title="kafka producer 的容错  kafka0.9 与 0.10"></a>kafka producer 的容错  kafka0.9 与 0.10</h4><ul>
<li>如果Flink开启了checkpoint，针对FlinkKafkaProducer09和FlinkKafkaProducer010 可以提供 at-least-once的语义，还需要配置下面两个参数<ul>
<li>setLogFailuresOnly(false)</li>
<li>setFlushOnCheckpoint(true)</li>
</ul>
</li>
<li>注意：建议修改kafka 生产者的重试次数<ul>
<li>retries【这个参数的值默认是0】</li>
</ul>
</li>
</ul>
<h4 id="Kafka-Producer的容错-Kafka-0-11"><a href="#Kafka-Producer的容错-Kafka-0-11" class="headerlink" title="Kafka Producer的容错-Kafka 0.11"></a>Kafka Producer的容错-Kafka 0.11</h4><ul>
<li>如果Flink开启了checkpoint，针对FlinkKafkaProducer011 就可以提供<br>exactly-once的语义</li>
<li>但是需要选择具体的语义<ul>
<li>Semantic.NONE</li>
<li>Semantic.AT_LEAST_ONCE【默认】</li>
<li>Semantic.EXACTLY_ONCE</li>
</ul>
</li>
</ul>

        </div>
        
          


  <section class='meta' id="footer-meta">
    <hr>
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-09-03T11:35:57+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>最后更新于 2019年9月3日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Flink/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>Flink</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/09/02/Flink详细介绍/&title=Flink详细介绍 | ZBlog&summary=
Flink详细介绍Flink API的抽象级别"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2019/09/02/Flink详细介绍/&title=Flink详细介绍 | ZBlog&summary=
Flink详细介绍Flink API的抽象级别"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/09/02/Flink详细介绍/&title=Flink详细介绍 | ZBlog&summary=
Flink详细介绍Flink API的抽象级别"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/09/11/Flink入门简介/" rel="prev" title="Flink入门简介">
                                  
                                      Flink入门简介
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Flink/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Flink</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/08/21/Python快速入门/" rel="prev" title="Python快速入门">
                                    
                                        Python快速入门
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Python-Python简介/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Python Python简介</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Flink详细介绍',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='https://raw.githubusercontent.com/zhaoxintaoaa/images/master/11.jpeg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="https://blog.csdn.net/qq_42244078"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@fastflink.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zhaoxintaoaa"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://cdn.zrahh.com/music/music.html"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink详细介绍"><span class="toc-text">Flink详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-API的抽象级别"><span class="toc-text">Flink API的抽象级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-DataStreamAPI"><span class="toc-text">Flink DataStreamAPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSource"><span class="toc-text">DataSource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transformation"><span class="toc-text">Transformation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sink"><span class="toc-text">sink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-DataSetAPI"><span class="toc-text">Flink DataSetAPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSource-1"><span class="toc-text">DataSource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transformations"><span class="toc-text">Transformations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sink-1"><span class="toc-text">sink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-SQL"><span class="toc-text">Flink SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Broadcast-amp-Accumulators-amp-Counters"><span class="toc-text">Flink Broadcast &amp; Accumulators &amp; Counters</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Broadcast广播变量"><span class="toc-text">Broadcast广播变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Accumulators-累加器"><span class="toc-text">Accumulators 累加器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Counters-计数器"><span class="toc-text">Counters 计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广播变量-Broadcast-与-累加变量-Accumlators的区别"><span class="toc-text">广播变量 Broadcast 与 累加变量 Accumlators的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Window和Time详解"><span class="toc-text">Flink Window和Time详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Window窗口"><span class="toc-text">Window窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Time介绍"><span class="toc-text">Time介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-并行度详解-Parallel"><span class="toc-text">Flink 并行度详解(Parallel )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskManager-与-Slot"><span class="toc-text">TaskManager 与 Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行度（Parallel）"><span class="toc-text">并行度（Parallel）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink的checkpoint机制"><span class="toc-text">Flink的checkpoint机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#checkpoint简介"><span class="toc-text">checkpoint简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkpoint的配置"><span class="toc-text">checkpoint的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state-Backend-状态的后端存储"><span class="toc-text">state Backend 状态的后端存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Kafka-Connector详解"><span class="toc-text">Flink Kafka-Connector详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-connector简介"><span class="toc-text">kafka-connector简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-consumer消费者策略"><span class="toc-text">kafka-consumer消费者策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka的容错"><span class="toc-text">kafka的容错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态加载topic"><span class="toc-text">动态加载topic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-consumer-offset-自动提交"><span class="toc-text">kafka consumer offset 自动提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-Producer"><span class="toc-text">Kafka Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-producer-的容错-kafka0-9-与-0-10"><span class="toc-text">kafka producer 的容错  kafka0.9 与 0.10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-Producer的容错-Kafka-0-11"><span class="toc-text">Kafka Producer的容错-Kafka 0.11</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/"
          
            rel="nofollow"
          
          
          id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/projects/" href="/projects/"
          
          
          id="projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/"
          
            rel="nofollow"
          
          
          id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/"
          
            rel="nofollow"
          
          
          id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/基础/" href="/categories/基础/"><div class='name'>基础</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/安装部署/" href="/categories/安装部署/"><div class='name'>安装部署</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/提高/" href="/categories/提高/"><div class='name'>提高</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/调优/" href="/categories/调优/"><div class='name'>调优</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/问题分析/" href="/categories/问题分析/"><div class='name'>问题分析</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/ELK/" style="font-size: 14px; color: #999">ELK</a> <a href="/tags/Elasticsearch/" style="font-size: 24px; color: #555">Elasticsearch</a> <a href="/tags/Elasticsearch-IK/" style="font-size: 14px; color: #999">Elasticsearch IK</a> <a href="/tags/Elasticsearch脑裂问题/" style="font-size: 14px; color: #999">Elasticsearch脑裂问题</a> <a href="/tags/Elasticsearch调优/" style="font-size: 14px; color: #999">Elasticsearch调优</a> <a href="/tags/Flink/" style="font-size: 19px; color: #777">Flink</a> <a href="/tags/Linux/" style="font-size: 19px; color: #777">Linux</a> <a href="/tags/Python-Python提高/" style="font-size: 14px; color: #999">Python Python提高</a> <a href="/tags/Python-Python简介/" style="font-size: 14px; color: #999">Python Python简介</a> <a href="/tags/maven/" style="font-size: 14px; color: #999">maven</a> <a href="/tags/storm/" style="font-size: 14px; color: #999">storm</a> <a href="/tags/storm-storm优化/" style="font-size: 14px; color: #999">storm storm优化</a> <a href="/tags/zookeeper/" style="font-size: 14px; color: #999">zookeeper</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="https://music.163.com/#/user/home?id=63035382"
    title="https://music.163.com/#/user/home?id=63035382">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2731158843"
    data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="https://blog.csdn.net/qq_42244078"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:me@fastflink.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zhaoxintaoaa"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://cdn.zrahh.com/music/music.html"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Blog Zhao</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
	
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1277958104'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277958104%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
</script>

  </div>
		<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
		<script>
			var now = new Date(); 
			function createtime() { 
				var grt= new Date("08/10/2017 17:38:00");//在此处修改你的建站时间
				now.setTime(now.getTime()+250); 
				days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
				hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
				if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
				mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
				seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
				snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
				document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
				document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
			} 
		setInterval("createtime()",250);
		</script>
		
</footer>
<script>setLoadingBarProgress(80);</script>




      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":120,"height":240,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>
