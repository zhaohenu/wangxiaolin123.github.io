<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhao</title>
  
  <subtitle>waiting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-21T06:16:42.337Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>赵鑫涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Storm高级以及优化</title>
    <link href="http://yoursite.com/2019/08/20/Storm%E9%AB%98%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/08/20/Storm高级/</id>
    <published>2019-08-20T13:04:14.623Z</published>
    <updated>2019-08-21T06:16:42.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Storm高级"><a href="#Storm高级" class="headerlink" title="Storm高级"></a>Storm高级</h3><h4 id="Storm核心之流分组"><a href="#Storm核心之流分组" class="headerlink" title="Storm核心之流分组"></a>Storm核心之流分组</h4><p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1566219022407.png" alt="1566219022407"></p><h5 id="stream-grouping-分类"><a href="#stream-grouping-分类" class="headerlink" title="stream grouping 分类"></a>stream grouping 分类</h5><ul><li>Shuffle Grouping：随机分组。将stream中的tuple缓存后随机发放给所有bolt，可以使每个bolt中的数据量大致相等（可以较好的实现负载均衡）</li><li>Fields Grouping：按字段分组，例如按groupID字段进行分组，将同一个分组的tuple分到统一任务中</li><li>All Grouping:广播发送，每一个tuple都会发送到所有任务中，所以每一个bolt都会有所有的tuple</li><li>Global Grouping：全局分组，这个tuple会被分配到storm中的某一个bolt,具体一点就是分配到ID值最小的一个bolt之中 <a id="more"></a></li><li>Non Grouping：随机分派，效果和shuffle一样</li><li>Direct Grouping：直接分组，将tuple发送给制定好的任务中</li><li>localOrShuffleGrouping：指如果目标Bolt 中的一个或者多个Task 和当前产生数据的Task在同一个Worker 进程里面，那么就走内部的线程间通信，将Tuple 直接发给在当前Worker进程的目的Task。否则，同shuffleGrouping。</li></ul><h4 id="Storm可靠性剖析"><a href="#Storm可靠性剖析" class="headerlink" title="Storm可靠性剖析"></a>Storm可靠性剖析</h4><h6 id="Storm可能出现的问题"><a href="#Storm可能出现的问题" class="headerlink" title="Storm可能出现的问题"></a>Storm可能出现的问题</h6><ul><li>worker进程死掉</li><li>supervisor进程死掉</li><li>nimbus进程死掉</li><li>节点宕机</li></ul><h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><ul><li>(acker机制)ack/fail消息确认机制(确保一个tuple被完全处理)<ul><li>在spout中发射tuple的时候需要同时发送messageid，这样才相当于开启了消息确认机制</li><li>如果你的topology里面的tuple比较多的话，那么把acker的数量设置多一点,效率会高一点。</li><li>通过config.setNumAckers(num)来设置一个topology里面的acker的数量，默认值是1。</li><li>注意：acker用了特殊的算法，使得对于追踪每个spout tuple的状态所需要的内存量是恒定的（20 bytes) </li><li>注意：如果一个tuple在指定的timeout(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS默认值为30秒)时间内没有被成功处理，那么这个tuple会被认为处理失败了。</li></ul></li></ul><h4 id="Storm定时器分析"><a href="#Storm定时器分析" class="headerlink" title="Storm定时器分析"></a>Storm定时器分析</h4><ul><li>可以指定每隔一段时间将数据整合一次存入数据库<ul><li>在main中设置conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, 60);// 设置本Bolt定时发射数据</li><li>在bolt中使用下面代码判断是否是触发用的bolt tuple.getSourceComponent().equals(Constants.SYSTEM_COMPONENT_ID)</li><li><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1566305060434.png" alt="1566305060434"></li></ul></li></ul><h4 id="StormUI的详解"><a href="#StormUI的详解" class="headerlink" title="StormUI的详解"></a>StormUI的详解</h4><p><img src="https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1566219892284.png" alt="1566219892284"></p><ul><li>deactive：未激活(暂停)</li><li>emitted:emitted tuple数<ul><li>与emitted的区别：如果一个task，emitted一个tuple到2个task中，则transferred tuple数是emitted tuple数的两倍</li></ul></li><li>completelatency: spout emitting 一个tuple到spout ack这个tuple的平均时间(可以认为是tuple以及该tuple树的整个处理时间)</li><li>processlatency:   bolt收到一个tuple到bolt ack这个tuple的平均时间，如果没有启动acker机制，那么值为0</li><li>execute latency：bolt处理一个tuple的平均时间，不包含acker操作，单位是毫秒(也就是bolt<br>执行 execute 方法的平均时间)</li><li>capacity：这个值越接近1，说明bolt或者spout基本一直在调用execute方法，说明并行度不够，需要扩展这个组件的executor数量。(调整组件并行度的依据)</li><li>总结：execute latency和proces latnecy是处理消息的时效性，而capacity则表示处理能力是否已经饱和，从这3个参数可以知道topology的瓶颈所在。</li></ul><h4 id="Storm的优化"><a href="#Storm的优化" class="headerlink" title="Storm的优化"></a>Storm的优化</h4><h5 id="并行度的优化"><a href="#并行度的优化" class="headerlink" title="并行度的优化"></a>并行度的优化</h5><ul><li>worker为storm提供工作进程，程序的并行度可以设置（包括spout和bolt的并行度，如果有acker的话还包括acker的并行度），并行度即为executor的数目。</li><li>一般情况下worker与executor的比例是一比十到十五，也可以根据实际需要修改。</li></ul><h5 id="worker的优化"><a href="#worker的优化" class="headerlink" title="worker的优化"></a>worker的优化</h5><ul><li>CPU 16核，建议配置20个worker。CPU 24或32核，30个worker</li><li>默认情况下，Storm启动worker进程时，JVM的最大内存是768M，可以通过在Strom的配置文件storm.yaml中设置worker的启动参数worker.childopts: “-Xmx2048m”</li><li>一个topology使用的worker数量，12个是比较合理的，这个时候吞吐量和整体性能最优。如果多增加worker进程的话，会将一些原本线程间的内存通信变为进程间的网络通信。</li></ul><h5 id="acker优化"><a href="#acker优化" class="headerlink" title="acker优化"></a>acker优化</h5><ul><li>如果可靠性对你来说不是那么重要，那么你可以通过不跟踪这些tuple树来获取更好的性能。不去跟踪消息的话会使得系统里面的消息数量减少一半，因为对于每一个tuple都要发送一个ack消息。</li><li>三种去掉可靠性的方法<ul><li>第一是把config.setNumAckers(0)设置为0，在这种情况下，storm会在spout发射一个tuple之后马上调用spout的ack方法。也就是说这个tuple树不会被跟踪。</li><li>第二个方法是在tuple层面去掉可靠性。你可以在发射tuple的时候不指定messageid来达到不跟踪spout中tuple的目的。</li><li>最后一个方法是如果你对于一个tuple树里面的某一部分到底成不成功不是很关心，那么可以在发射这些tuple的时候unanchor它们(anchor是锚定的意思，unanchor表示不把当前这个tuple包含到tuple树中，也就是说不跟踪这个消息了)。这样这些tuple就不在tuple树里面， 也就不会被跟踪了。</li></ul></li></ul><h4 id="雪崩问题的出现原因以及解决方法"><a href="#雪崩问题的出现原因以及解决方法" class="headerlink" title="雪崩问题的出现原因以及解决方法"></a>雪崩问题的出现原因以及解决方法</h4><ul><li>原因：spout发送的速度大于bolt接收的速度，导致数据堆积，不断消耗内存，最终系统崩溃，并引起数据链上多节点down掉。</li><li>解决方案<ul><li>增加bolt的并行度 增加它接收的速度</li><li>可以通过topology.max.spout.pending来控制spout发送消息的速度，通过代码这样设置config.setMaxSpoutPending(num);<ul><li>注意：这个参数表示，当下游的bolt还有topology.max.spout.pending个 tuple 没有消费完时，spout会停止调用nexttuple方法发射数据。等待下游bolt去消费，当tuple的个数少于topology.max.spout.pending个数时，spout 会继续发射数据(这个属性只对可靠消息处理有用，也就是说需要启用acker消息确认机制，在spout中emit数据的时候需要带有messageid)</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Storm高级&quot;&gt;&lt;a href=&quot;#Storm高级&quot; class=&quot;headerlink&quot; title=&quot;Storm高级&quot;&gt;&lt;/a&gt;Storm高级&lt;/h3&gt;&lt;h4 id=&quot;Storm核心之流分组&quot;&gt;&lt;a href=&quot;#Storm核心之流分组&quot; class=&quot;headerlink&quot; title=&quot;Storm核心之流分组&quot;&gt;&lt;/a&gt;Storm核心之流分组&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhaoxintaoaa/images/master/1566219022407.png&quot; alt=&quot;1566219022407&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;stream-grouping-分类&quot;&gt;&lt;a href=&quot;#stream-grouping-分类&quot; class=&quot;headerlink&quot; title=&quot;stream grouping 分类&quot;&gt;&lt;/a&gt;stream grouping 分类&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Shuffle Grouping：随机分组。将stream中的tuple缓存后随机发放给所有bolt，可以使每个bolt中的数据量大致相等（可以较好的实现负载均衡）&lt;/li&gt;
&lt;li&gt;Fields Grouping：按字段分组，例如按groupID字段进行分组，将同一个分组的tuple分到统一任务中&lt;/li&gt;
&lt;li&gt;All Grouping:广播发送，每一个tuple都会发送到所有任务中，所以每一个bolt都会有所有的tuple&lt;/li&gt;
&lt;li&gt;Global Grouping：全局分组，这个tuple会被分配到storm中的某一个bolt,具体一点就是分配到ID值最小的一个bolt之中
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven 简介</title>
    <link href="http://yoursite.com/2019/01/21/maven%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/01/21/maven的简介/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-08-21T06:02:45.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven 简介"></a>Maven 简介</h2><h3 id="为什么需要maven"><a href="#为什么需要maven" class="headerlink" title="为什么需要maven"></a>为什么需要maven</h3><ul><li>同样的代码要在不同的机器上运行他所需要的依赖可以放在maven仓库</li><li>项目组加入新成员可以快速的配置好环境</li><li>在开发其他项目的时候需要用到跟之前项目开发一样的jar包</li></ul><a id="more"></a><h3 id="maven是什么"><a href="#maven是什么" class="headerlink" title="maven是什么"></a>maven是什么</h3><ul><li>maven是基于项目对象模型POM的软件项目管理工具</li><li>是可以跨平台的，主要服务基于Java平台的仙姑构建、依赖管理、项目信息管理等</li></ul><h5 id="构建的过程"><a href="#构建的过程" class="headerlink" title="构建的过程"></a>构建的过程</h5><ul><li>清理</li><li>编译</li><li>测试</li><li>报告</li><li>打包</li><li>部署</li></ul><h3 id="maven的工程结构"><a href="#maven的工程结构" class="headerlink" title="maven的工程结构"></a>maven的工程结构</h3><ul><li>src </li><li><ul><li>mian</li><li><ul><li>java   – 存放Java的文件 源代码等</li><li>resource   –存放资源文件 比如 spring，hibernate等的配置文件</li></ul></li><li>test</li><li><ul><li>Java   – 存放所有的.Java的测试文件，比如JUnit 测试类</li><li>resource   –测试的资源文件夹</li></ul></li></ul></li><li>target       —目标文件的输出位置比如jar包、war包等</li><li>pom.xml      —maven的项目核心配置文件</li></ul><h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><ul><li>mvn compile  执行编译 会将生成文件存放在target目录中</li><li>mvn clean  删除target中的目录文件</li><li>mvn test    执行测试命令 执行后会在target目录中生成三个目录文件surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）</li><li>mvn  package 进行打包操作 操作后的文件存放在target目录之中 例如jar包war包</li><li>mvn install  将制定的jar包安装到本地仓库以便于其他工程的引用</li><li>mvn clean compile 清除测试类再执行compile执行编译操作</li><li>mvn clean test  先清除在进行test测试操作</li><li>mvn clean package 先执行clean清除在执行package打包</li><li>mvn clean install  先进行clean在执行install</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven-简介&quot;&gt;&lt;a href=&quot;#Maven-简介&quot; class=&quot;headerlink&quot; title=&quot;Maven 简介&quot;&gt;&lt;/a&gt;Maven 简介&lt;/h2&gt;&lt;h3 id=&quot;为什么需要maven&quot;&gt;&lt;a href=&quot;#为什么需要maven&quot; class=&quot;headerlink&quot; title=&quot;为什么需要maven&quot;&gt;&lt;/a&gt;为什么需要maven&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;同样的代码要在不同的机器上运行他所需要的依赖可以放在maven仓库&lt;/li&gt;
&lt;li&gt;项目组加入新成员可以快速的配置好环境&lt;/li&gt;
&lt;li&gt;在开发其他项目的时候需要用到跟之前项目开发一样的jar包&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
